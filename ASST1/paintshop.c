#include <types.h>
#include <lib.h>
#include <synch.h>
#include <test.h>
#include <thread.h>


#include "paintshop.h"

#include "paintshop_driver.h"

void order_paint(paint_can *can);
void go_home(void);
void * take_order(void);
void fill_order(void *v);
void serve_order(void *v);
void paintshop_open(void);
void paintshop_close(void);
void wait_on_tints(struct paintcan *c);
void signal_on_tints(struct paintcan *c);

/*
 * **********************************************************************
 * YOU ARE FREE TO CHANGE THIS FILE BELOW THIS POINT AS YOU SEE FIT
 *
 */



/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY CUSTOMER THREADS
 * **********************************************************************
 */

/*
 * order_paint()
 *
 * Takes one argument specifying the can to be filled. The function
 * makes the can available to staff threads and then blocks until the staff
 * have filled the can with the appropriately tinted paint.
 *
 * The can itself contains an array of requested tints.
 */ 

void order_paint(struct paintcan *can)
{
    // Places order
    // Waits if order buffer is full
    P(empty_order);
    P(access_orders);
    int i;
    for(i = 0; i < NCUSTOMERS; i++)
    {
        if(order_buffer[i] == NULL)
        {
            order_buffer[i] = can;
            break;
        }
    }
    V(access_orders);
    V(full_order);


    int found = 0;
    while(!found) { 
	// Scans the done buffer for the ordered can 
	// Sleeps and let other customer to scan for cans, if not found
	P(order_ready);
	P(access_done);
	int i;
	for(i = 0; i < NCUSTOMERS; i++) {
	    if(can == (struct paintcan *) done_can[i]) {
		done_can[i] = NULL;
		found = 1;
		break;
	    }
	}
	V(access_done);
	if(!found) {
	    V(order_ready);
	    thread_yield();
	}
    }
}



/*
 * go_home()
 *
 * This function is called by customers when they go home. It could be
 * used to keep track of the number of remaining customers to allow
 * paint shop staff threads to exit when no customers remain.
 */

void go_home()
{
    // update remaining customer
    remaining_customers--;
}


/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY PAINT SHOP STAFF THREADS
 * **********************************************************************
 */

/*
 * take_order()
 *
 * This function waits for a new order to be submitted by
 * customers. When submitted, it records the details, and returns a
 * pointer to something representing the order.
 *
 * The return pointer type is void * to allow freedom of representation
 * of orders.
 *
 * The function can return NULL to signal the staff thread it can now
 * exit as their are no customers nor orders left. 
 */
 
void * take_order()
{
    // if there is no customer, returns null
    // otherwise, a order from order buffer
    void *order;
    while(1){
        if(remaining_customers == 0)
        {
	    return NULL;
        }

        bool flag = false;
        P(full_order);
        P(access_orders);
        int i;
        for(i = 0; i < NCUSTOMERS; i++)
        {
            if(order_buffer[i] != NULL)
            {
	        order = (void *)order_buffer[i];
                order_buffer[i] = NULL;
	        flag = true;
                break;
            }
        }

        V(access_orders);
        V(full_order);
        if(flag){
            V(empty_order);
       	    break;    
        }
    }
    return order;
}


/*
 * fill_order()
 *
 * This function takes an order generated by take order and fills the
 * order using the mix() function to tint the paint.
 *
 * NOTE: IT NEEDS TO ENSURE THAT MIX HAS EXCLUSIVE ACCESS TO THE TINTS
 * IT NEEDS TO USE TO FILE THE ORDER.
 */
void wait_on_tints(struct paintcan *c){
    int i;
    int tint;
    for(i = 0; i < PAINT_COMPLEXITY; i++) {
	tint = c->requested_colours[i] - 1;
      	if(tint >= 0)
	    P(access_tints[tint]);   
    }
}
void signal_on_tints(struct paintcan *c){
    int i;
    int tint;   
    for(i = 0; i < PAINT_COMPLEXITY; i++) {
	tint = c->requested_colours[i] - 1;
	if(tint >= 0)
	    V(access_tints[tint]);   
    }
}
void fill_order(void *v)
{
    wait_on_tints(v); // lock required tints only in the increasing order
    mix(v);	// mixes using acquired tints
    signal_on_tints(v); // release locks on tints
}


/*
 * serve_order()
 *
 * Takes a filled order and makes it available to the waiting customer.
 */

void serve_order(void *v)
{
    // put mixed order on done buffer
    int i;
    P(access_done);
    for(i = 0; i < NCUSTOMERS; i++) {
	if(done_can[i] == NULL) {
	    done_can[i] = v;
	    break;
        }
    }
    V(access_done);
    V(order_ready);
}



/*
 * **********************************************************************
 * INITIALISATION AND CLEANUP FUNCTIONS
 * **********************************************************************
 */


/*
 * paintshop_open()
 *
 * Perform any initialisation you need prior to opening the paint shop to
 * staff and customers
 */

void paintshop_open()
{
    remaining_customers = NCUSTOMERS; //Initialize remaining customers as total customers
    
    // Initializing neccesary semaphores
    access_orders = sem_create("access_orders", 1);
    empty_order = sem_create("empty_order", NCUSTOMERS);
    full_order = sem_create("full_order", 0);
    
    access_done   = sem_create("access_done", 1);
    order_ready   = sem_create("order_ready", 0);
	
    if(NCUSTOMERS>10000){
        panic("CUSTOMERS more than 10000 is not supported");
    }
    if(NCOLOURS>10000){
        panic("Color more than 10000 is not supported");
    }
    // Initializing mutex semaphore for each tint of color
    int i;
    for(i = 0 ; i < NCOLOURS ; i++)
        access_tints[i] = sem_create("access_tints", 1);

}

/*
 * paintshop_close()
 *
 * Perform any cleanup after the paint shop has closed and everybody
 * has gone home.
 */

void paintshop_close()
{
    // destroying all semaphores
    sem_destroy(access_orders);
    sem_destroy(empty_order);
    sem_destroy(full_order);
    sem_destroy(access_done);
    sem_destroy(order_ready);

    int i;
    for(i = 0 ; i < NCOLOURS ; i++)
        sem_destroy(access_tints[i]);

}
