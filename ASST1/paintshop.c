#include <types.h>
#include <lib.h>
#include <synch.h>
#include <test.h>
#include <thread.h>

#include "paintshop_driver.h"

#include "paintshop.h"


/*
 * **********************************************************************
 * YOU ARE FREE TO CHANGE THIS FILE BELOW THIS POINT AS YOU SEE FIT
 *
 */



/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY CUSTOMER THREADS
 * **********************************************************************
 */

/*
 * order_paint()
 *
 * Takes one argument specifying the can to be filled. The function
 * makes the can available to staff threads and then blocks until the staff
 * have filled the can with the appropriately tinted paint.
 *
 * The can itself contains an array of requested tints.
 */ 
struct queue *
q_create(int size)
{

	struct queue *q = kmalloc(sizeof(struct queue));
	if (q==NULL) {
		return NULL;
	}
	q->size = size;
	q->data = kmalloc(size * sizeof(void *));
	if (q->data==NULL) {
		kfree(q);
		return NULL;
	}
	q->nextread = q->nextwrite = 0;
	return q;
}
int
q_grow(struct queue *q, int targetsize)
{
	void **olddata = q->data;
	int onr = q->nextread;
	int onw = q->nextwrite;
	int osize = q->size;

	int nsize;
	void **ndata;

	int i, result;

	nsize = q->size;
	while (nsize < targetsize) {
		nsize *= 2;
		/* prevent infinite loop */
		//assert(nsize > 0);
	}
	ndata = kmalloc(nsize * sizeof(void *));
	if (ndata == NULL) {
		return 1;
	}
	q->size = nsize;
	q->data = ndata;
	q->nextread = q->nextwrite = 0;
	
	for (i=onr; i!=onw; i = (i+1)%osize) {
		result = q_addtail(q, olddata[i]);
		//assert(result==0);
	}
	kfree(olddata);
	return 0;
}
int
q_addtail(struct queue *q, void *ptr)
{
	int nextnext, result;

	//assert(q->size > 0);

	nextnext = (q->nextwrite+1) % q->size;
	if (nextnext==q->nextread) {
		result = q_grow(q, q->size+1);
		if (result) {
			return result;
		}
		nextnext = (q->nextwrite+1) % q->size;
	}
	q->data[q->nextwrite] = ptr;
	q->nextwrite = nextnext;
	return 0;
}
int
q_empty(struct queue *q)
{
	return q->nextwrite == q->nextread;
}

void *
q_remhead(struct queue *q)
{
	void *ret;

	//assert(q->size > 0);

	//assert(!q_empty(q));
	ret = q->data[q->nextread];
	q->nextread = (q->nextread+1)%q->size;
	return ret;
}
void
q_destroy(struct queue *q)
{
	//assert(q_empty(q));
	kfree(q->data);
	kfree(q);
}

void order_paint(struct paintcan *can)
{
	P(access_orders);
	q_addtail(orders, can);
	V(access_orders);

	int found = 0;
	while(!found) {
		P(order_ready);
		P(access_done);
		int i;
		for(i = 0; i < NCUSTOMERS; i++) {
			if(can == (struct paintcan *) done_can[i]) {
				done_can[i] = NULL;
				found = 1;
				break;
			}
		}
		V(access_done);
		if(!found) {
			V(order_ready);
			thread_yield();
		}
	}


}



/*
 * go_home()
 *
 * This function is called by customers when they go home. It could be
 * used to keep track of the number of remaining customers to allow
 * paint shop staff threads to exit when no customers remain.
 */

void go_home()
{
remaining_customers--;
}



/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY PAINT SHOP STAFF THREADS
 * **********************************************************************
 */

/*
 * take_order()
 *
 * This function waits for a new order to be submitted by
 * customers. When submitted, it records the details, and returns a
 * pointer to something representing the order.
 *
 * The return pointer type is void * to allow freedom of representation
 * of orders.
 *
 * The function can return NULL to signal the staff thread it can now
 * exit as their are no customers nor orders left. 
 */
 
void * take_order()
{
void *ret;

	P(access_orders);
	while(q_empty(orders)) {
		V(access_orders);
		if(remaining_customers == 0) {
			ret = NULL;
			return ret;
		}
		else {
			thread_yield();
			P(access_orders);
		}
	}

	ret = q_remhead(orders);
	V(access_orders);

	return ret;
}


/*
 * fill_order()
 *
 * This function takes an order generated by take order and fills the
 * order using the mix() function to tint the paint.
 *
 * NOTE: IT NEEDS TO ENSURE THAT MIX HAS EXCLUSIVE ACCESS TO THE TINTS
 * IT NEEDS TO USE TO FILE THE ORDER.
 */

void fill_order(void *v)
{
P(access_tints);
	mix(v);
	V(access_tints);
}


/*
 * serve_order()
 *
 * Takes a filled order and makes it available to the waiting customer.
 */

void serve_order(void *v)
{
int i;
	P(access_done);
	for(i = 0; i < NCUSTOMERS; i++) {
		if(done_can[i] == NULL) {
			done_can[i] = v;
			break;
		}
	}
	V(access_done);
	V(order_ready);
}



/*
 * **********************************************************************
 * INITIALISATION AND CLEANUP FUNCTIONS
 * **********************************************************************
 */


/*
 * paintshop_open()
 *
 * Perform any initialisation you need prior to opening the paint shop to
 * staff and customers
 */

void paintshop_open()
{

remaining_customers = NCUSTOMERS;
	orders = q_create(NCUSTOMERS);
	access_orders = sem_create("access_orders", 1);
	access_done   = sem_create("access_done", 1);
	order_ready   = sem_create("order_ready", 0);
	access_tints  = sem_create("access_tints", 1);
	int i;
	for(i = 0; i < NCUSTOMERS; i++) {
		done_can[i] = NULL;
	}
}

/*
 * paintshop_close()
 *
 * Perform any cleanup after the paint shop has closed and everybody
 * has gone home.
 */

void paintshop_close()
{q_destroy(orders);
	sem_destroy(access_orders);
	sem_destroy(access_done);
	sem_destroy(order_ready);
	sem_destroy(access_tints);
}
